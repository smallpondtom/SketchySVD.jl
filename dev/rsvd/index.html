<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Randomized SVD · SketchySVD</title><meta name="title" content="Randomized SVD · SketchySVD"/><meta property="og:title" content="Randomized SVD · SketchySVD"/><meta property="twitter:title" content="Randomized SVD · SketchySVD"/><meta name="description" content="Documentation for SketchySVD."/><meta property="og:description" content="Documentation for SketchySVD."/><meta property="twitter:description" content="Documentation for SketchySVD."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SketchySVD</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Mathematical Background</span><ul><li><a class="tocitem" href="../theory/">Theory</a></li><li><a class="tocitem" href="../sketching/">Sketching Algorithms</a></li><li class="is-active"><a class="tocitem" href>Randomized SVD</a><ul class="internal"><li><a class="tocitem" href="#Basic-Algorithm"><span>Basic Algorithm</span></a></li><li><a class="tocitem" href="#Power-Iterations"><span>Power Iterations</span></a></li><li><a class="tocitem" href="#Transpose-Trick"><span>Transpose Trick</span></a></li><li><a class="tocitem" href="#Adaptive-Rank-Selection"><span>Adaptive Rank Selection</span></a></li><li><a class="tocitem" href="#Random-Matrix-Types"><span>Random Matrix Types</span></a></li><li><a class="tocitem" href="#Error-Bounds"><span>Error Bounds</span></a></li><li><a class="tocitem" href="#Parameter-Selection-Guidelines"><span>Parameter Selection Guidelines</span></a></li><li><a class="tocitem" href="#Computational-Complexity"><span>Computational Complexity</span></a></li><li><a class="tocitem" href="#Numerical-Stability"><span>Numerical Stability</span></a></li><li><a class="tocitem" href="#Implementation-in-SketchySVD.jl"><span>Implementation in SketchySVD.jl</span></a></li><li><a class="tocitem" href="#Comparison:-Batch-rSVD-vs-Streaming-SketchySVD"><span>Comparison: Batch rSVD vs Streaming SketchySVD</span></a></li></ul></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../quickstart/">Getting Started</a></li><li><a class="tocitem" href="../redux_maps/">Dimension Reduction Maps</a></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li><li><a class="tocitem" href="../paper/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Mathematical Background</a></li><li class="is-active"><a href>Randomized SVD</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Randomized SVD</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/smallpondtom/SketchySVD.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/smallpondtom/SketchySVD.jl/blob/https://github.com/smallpondtom/SketchySVD.jl/docs/src/rsvd.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Randomized-SVD"><a class="docs-heading-anchor" href="#Randomized-SVD">Randomized SVD</a><a id="Randomized-SVD-1"></a><a class="docs-heading-anchor-permalink" href="#Randomized-SVD" title="Permalink"></a></h1><p>The Randomized SVD (rSVD) is a fast algorithm for computing approximate singular value decompositions using randomized sampling techniques [<a href="../paper/#HMT2011">2</a>].</p><h2 id="Basic-Algorithm"><a class="docs-heading-anchor" href="#Basic-Algorithm">Basic Algorithm</a><a id="Basic-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Algorithm" title="Permalink"></a></h2><p>Given a matrix <span>$A \in \mathbb{R}^{m \times n}$</span> and target rank <span>$k$</span>, randomized SVD computes an approximation <span>$A \approx U \Sigma V^T$</span> using the following steps:</p><h3 id="Algorithm-Steps"><a class="docs-heading-anchor" href="#Algorithm-Steps">Algorithm Steps</a><a id="Algorithm-Steps-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-Steps" title="Permalink"></a></h3><p><strong>1. Random Sampling</strong></p><p>Generate a random test matrix <span>$G \in \mathbb{R}^{n \times \ell}$</span> where <span>$\ell = k + p$</span> (<span>$p$</span> is oversampling parameter):</p><p class="math-container">\[G = \text{randn}(n, \ell)\]</p><p><strong>2. Range Approximation</strong></p><p>Form the sample matrix and orthonormalize:</p><p class="math-container">\[Y = AG, \quad Q = \text{orth}(Y)\]</p><p>where <span>$Q \in \mathbb{R}^{m \times \ell}$</span> has orthonormal columns that approximate the range of <span>$A$</span>.</p><p><strong>3. Dimensionality Reduction</strong></p><p>Project <span>$A$</span> onto the low-dimensional subspace:</p><p class="math-container">\[B = Q^T A \in \mathbb{R}^{\ell \times n}\]</p><p><strong>4. SVD of Small Matrix</strong></p><p>Compute the SVD of the small matrix <span>$B$</span>:</p><p class="math-container">\[B = \tilde{U} \tilde{\Sigma} \tilde{V}^T\]</p><p><strong>5. Recover Approximate SVD</strong></p><p>Construct the approximate SVD of <span>$A$</span>:</p><p class="math-container">\[U = Q\tilde{U}_{:,1:k}, \quad \Sigma = \tilde{\Sigma}_{1:k,1:k}, \quad V = \tilde{V}_{:,1:k}\]</p><h2 id="Power-Iterations"><a class="docs-heading-anchor" href="#Power-Iterations">Power Iterations</a><a id="Power-Iterations-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Iterations" title="Permalink"></a></h2><p>For improved accuracy, especially when the singular values decay slowly, power iterations can be applied:</p><pre><code class="language-julia hljs">function rsvd_with_power(A, k; p=5, q=2)
    m, n = size(A)
    ℓ = k + p
    
    # Random matrix
    G = randn(n, ℓ)
    
    # Form sample and orthonormalize
    Y = A * G
    Q = Matrix(qr!(Y).Q)
    
    # Power iterations
    for j in 1:q
        # Z = orth(A&#39; * Q)
        Z = A&#39; * Q
        Z = Matrix(qr!(Z).Q)
        
        # Q = orth(A * Z)
        Q = A * Z
        Q = Matrix(qr!(Q).Q)
    end
    
    # Compute SVD
    B = Q&#39; * A
    F = svd!(B)
    
    # Extract rank-k approximation
    U = Q * F.U[:, 1:k]
    S = F.S[1:k]
    V = F.V[:, 1:k]
    
    return U, S, V
end</code></pre><p><strong>Effect</strong>: Each power iteration amplifies the dominant singular values by <span>$\sigma_i^2$</span>, improving the approximation.</p><p><strong>Recommendation</strong>: Use <span>$q=1$</span> or <span>$q=2$</span> power iterations for most applications.</p><h2 id="Transpose-Trick"><a class="docs-heading-anchor" href="#Transpose-Trick">Transpose Trick</a><a id="Transpose-Trick-1"></a><a class="docs-heading-anchor-permalink" href="#Transpose-Trick" title="Permalink"></a></h2><p>For tall-thin matrices (<span>$m \gg n$</span>), it&#39;s more efficient to work with <span>$A^T$</span>:</p><pre><code class="language-julia hljs">function rsvd_transpose(A, k; p=5, q=0)
    m, n = size(A)
    @assert m &gt; 5*n &quot;Use standard rSVD for non-tall matrices&quot;
    
    ℓ = k + p
    
    # Work with transpose
    G = randn(m, ℓ)
    Y = A&#39; * G
    Q = Matrix(qr!(Y).Q)
    
    # Power iterations (if q &gt; 0)
    for j in 1:q
        Z = A * Q
        Z = Matrix(qr!(Z).Q)
        Q = A&#39; * Z
        Q = Matrix(qr!(Q).Q)
    end
    
    # Compute SVD
    B = (A * Q)&#39;
    F = svd!(B)
    
    # U and V are swapped
    V = Q * F.U[:, 1:k]
    S = F.S[1:k]
    U = F.V[:, 1:k]
    
    return U, S, V
end</code></pre><p><strong>Speedup</strong>: Reduces complexity from <span>$O(mn^2)$</span> to <span>$O(m n \ell)$</span> when <span>$\ell \ll n$</span>.</p><h2 id="Adaptive-Rank-Selection"><a class="docs-heading-anchor" href="#Adaptive-Rank-Selection">Adaptive Rank Selection</a><a id="Adaptive-Rank-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-Rank-Selection" title="Permalink"></a></h2><p>The <code>rsvd_adaptive</code> function automatically determines the effective rank based on singular value decay:</p><pre><code class="language-julia hljs">function rsvd_adaptive(A, k_max; tol=1e-10, p=5, q=0)
    # Compute rSVD with k_max
    U, S, V = rsvd(A, k_max, p=p, q=q)
    
    # Find cutoff where S[i] &lt; tol * S[1]
    cutoff = findfirst(s -&gt; s &lt; tol * S[1], S)
    
    if isnothing(cutoff)
        return U, S, V
    else
        k_actual = cutoff - 1
        return U[:, 1:k_actual], S[1:k_actual], V[:, 1:k_actual]
    end
end</code></pre><p><strong>Use case</strong>: When the effective rank is unknown but you have a tolerance threshold.</p><h2 id="Random-Matrix-Types"><a class="docs-heading-anchor" href="#Random-Matrix-Types">Random Matrix Types</a><a id="Random-Matrix-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Random-Matrix-Types" title="Permalink"></a></h2><p>SketchySVD supports multiple random matrix types for different trade-offs:</p><h3 id="1.-Gaussian-(Standard)"><a class="docs-heading-anchor" href="#1.-Gaussian-(Standard)">1. Gaussian (Standard)</a><a id="1.-Gaussian-(Standard)-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Gaussian-(Standard)" title="Permalink"></a></h3><pre><code class="language-julia hljs">G = randn(n, ℓ)</code></pre><p><strong>Properties</strong>:</p><ul><li>Dense matrix</li><li>Strong theoretical guarantees</li><li>Standard choice for general matrices</li></ul><p><strong>Complexity</strong>: <span>$O(mn\ell)$</span> per multiplication</p><h3 id="2.-Rademacher-(1-entries)"><a class="docs-heading-anchor" href="#2.-Rademacher-(1-entries)">2. Rademacher (±1 entries)</a><a id="2.-Rademacher-(1-entries)-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Rademacher-(1-entries)" title="Permalink"></a></h3><pre><code class="language-julia hljs">G = Float64.(rand([-1, 1], n, ℓ))</code></pre><p><strong>Properties</strong>:</p><ul><li>Faster generation than Gaussian</li><li>Similar performance to Gaussian</li><li>Smaller storage (can use Int8)</li></ul><p><strong>Complexity</strong>: Same as Gaussian, but faster generation</p><h3 id="3.-Sparse-Gaussian"><a class="docs-heading-anchor" href="#3.-Sparse-Gaussian">3. Sparse Gaussian</a><a id="3.-Sparse-Gaussian-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Sparse-Gaussian" title="Permalink"></a></h3><pre><code class="language-julia hljs">using SparseArrays
G = sprandn(n, ℓ, density)</code></pre><p><strong>Properties</strong>:</p><ul><li>Much faster multiplication for large <span>$n$</span></li><li>Requires higher oversampling <span>$p$</span></li><li>Good for very large matrices</li></ul><p><strong>Complexity</strong>: <span>$O(mn\cdot \text{density} \cdot \ell)$</span></p><p><strong>Recommendation</strong>: Use <span>$density \approx \min(1, \frac{\log \ell}{n})$</span></p><h3 id="4.-Subsampled-Randomized-Fourier-Transform-(SRFT)"><a class="docs-heading-anchor" href="#4.-Subsampled-Randomized-Fourier-Transform-(SRFT)">4. Subsampled Randomized Fourier Transform (SRFT)</a><a id="4.-Subsampled-Randomized-Fourier-Transform-(SRFT)-1"></a><a class="docs-heading-anchor-permalink" href="#4.-Subsampled-Randomized-Fourier-Transform-(SRFT)" title="Permalink"></a></h3><pre><code class="language-julia hljs">G = srft_matrix(n, ℓ)</code></pre><p><strong>Properties</strong>:</p><ul><li>Implicitly formed (not stored)</li><li>Very fast via FFT</li><li>Excellent for structured matrices</li></ul><p><strong>Complexity</strong>: <span>$O(mn \log n)$</span> using FFT</p><p><strong>Structure</strong>:</p><p class="math-container">\[G = \sqrt{\frac{n}{\ell}} \cdot R \cdot F \cdot D\]</p><p>where:</p><ul><li><span>$D$</span>: diagonal with random ±1 entries</li><li><span>$F$</span>: DFT matrix (applied via FFT)</li><li><span>$R$</span>: row sampling (selects <span>$\ell$</span> rows)</li></ul><h2 id="Error-Bounds"><a class="docs-heading-anchor" href="#Error-Bounds">Error Bounds</a><a id="Error-Bounds-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Bounds" title="Permalink"></a></h2><p>For a rank-<span>$\rho$</span> matrix approximated by rank-<span>$k$</span> rSVD:</p><p><strong>Expected error</strong> [<a href="../paper/#HMT2011">2</a>]:</p><p class="math-container">\[\mathbb{E}[\|A - U\Sigma V^T\|_F] \leq \left(1 + \frac{k}{p-1}\right)^{1/2} \left(\sum_{i=k+1}^{\rho} \sigma_i^2\right)^{1/2}\]</p><p><strong>With <span>$q$</span> power iterations</strong> [<a href="../paper/#M2019">3</a>]:</p><p class="math-container">\[\mathbb{E}[\|A - U\Sigma V^T\|_2] \leq \left[ (1 + \sqrt{\frac{k}{p-1}})\sigma_{k+1}^{2q+1} + \frac{e\sqrt{k+p}}{p}\left( \sum_{j=k+1}^{\min(m,n)}\sigma_{j}^{2(2q+1)} \right)^{1/2} \right]^{1/(2q+1)}\]</p><p><strong>Key insights</strong>:</p><ul><li>Error decreases with oversampling <span>$p$</span></li><li>Power iterations drastically reduce error</li><li>Error bounded by tail singular values</li></ul><h2 id="Parameter-Selection-Guidelines"><a class="docs-heading-anchor" href="#Parameter-Selection-Guidelines">Parameter Selection Guidelines</a><a id="Parameter-Selection-Guidelines-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Selection-Guidelines" title="Permalink"></a></h2><h3 id="Oversampling-Parameter-p"><a class="docs-heading-anchor" href="#Oversampling-Parameter-p">Oversampling Parameter <span>$p$</span></a><a id="Oversampling-Parameter-p-1"></a><a class="docs-heading-anchor-permalink" href="#Oversampling-Parameter-p" title="Permalink"></a></h3><table><tr><th style="text-align: right">Value</th><th style="text-align: right">Use Case</th></tr><tr><td style="text-align: right"><span>$p=5$</span></td><td style="text-align: right">Default, good balance</td></tr><tr><td style="text-align: right"><span>$p=10$</span></td><td style="text-align: right">High accuracy required</td></tr><tr><td style="text-align: right"><span>$p=0\text{-}2$</span></td><td style="text-align: right">Speed priority, good spectrum</td></tr></table><h3 id="Power-Iterations-q"><a class="docs-heading-anchor" href="#Power-Iterations-q">Power Iterations <span>$q$</span></a><a id="Power-Iterations-q-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Iterations-q" title="Permalink"></a></h3><table><tr><th style="text-align: right">Value</th><th style="text-align: right">Use Case</th></tr><tr><td style="text-align: right"><span>$q=0$</span></td><td style="text-align: right">Fast approximation, well-conditioned</td></tr><tr><td style="text-align: right"><span>$q=1$</span></td><td style="text-align: right">Standard accuracy</td></tr><tr><td style="text-align: right"><span>$q=2$</span></td><td style="text-align: right">High accuracy</td></tr><tr><td style="text-align: right"><span>$q\geq 3$</span></td><td style="text-align: right">Ill-conditioned matrices</td></tr></table><h3 id="Transpose-Trick-2"><a class="docs-heading-anchor" href="#Transpose-Trick-2">Transpose Trick</a><a class="docs-heading-anchor-permalink" href="#Transpose-Trick-2" title="Permalink"></a></h3><p><strong>Use when</strong>: <span>$m &gt; 5n$</span> and <span>$k + p &lt; n$</span></p><p><strong>Speedup</strong>: Approximately <span>$\frac{m}{5n}$</span> times faster</p><h2 id="Computational-Complexity"><a class="docs-heading-anchor" href="#Computational-Complexity">Computational Complexity</a><a id="Computational-Complexity-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-Complexity" title="Permalink"></a></h2><table><tr><th style="text-align: right">Operation</th><th style="text-align: right">Standard SVD</th><th style="text-align: right">rSVD (no power)</th><th style="text-align: right">rSVD (q power)</th></tr><tr><td style="text-align: right">Time</td><td style="text-align: right"><span>$O(mn\min(m,n))$</span></td><td style="text-align: right"><span>$O(mn\ell)$</span></td><td style="text-align: right"><span>$O(qmn\ell)$</span></td></tr><tr><td style="text-align: right">Space</td><td style="text-align: right"><span>$O(mn)$</span></td><td style="text-align: right"><span>$O(m\ell + n\ell)$</span></td><td style="text-align: right">Same</td></tr></table><p>Where <span>$\ell = k + p \ll \min(m,n)$</span>.</p><p><strong>Example</strong>: For <span>$m=10000, n=5000, k=50, p=10$</span>:</p><ul><li>Standard SVD: <span>$\sim 10^{12}$</span> operations</li><li>rSVD: <span>$\sim 3 \times 10^9$</span> operations</li><li><strong>Speedup</strong>: ~300×</li></ul><h2 id="Numerical-Stability"><a class="docs-heading-anchor" href="#Numerical-Stability">Numerical Stability</a><a id="Numerical-Stability-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Stability" title="Permalink"></a></h2><h3 id="Orthonormalization"><a class="docs-heading-anchor" href="#Orthonormalization">Orthonormalization</a><a id="Orthonormalization-1"></a><a class="docs-heading-anchor-permalink" href="#Orthonormalization" title="Permalink"></a></h3><p>Use QR factorization for numerical stability:</p><pre><code class="language-julia hljs">Q = Matrix(qr!(Y).Q)  # Stable orthonormalization</code></pre><p><strong>Avoid</strong>: Gram-Schmidt without reorthogonalization (unstable)</p><h3 id="Precision-Considerations"><a class="docs-heading-anchor" href="#Precision-Considerations">Precision Considerations</a><a id="Precision-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Precision-Considerations" title="Permalink"></a></h3><p>For very ill-conditioned matrices:</p><ol><li>Use more power iterations</li><li>Increase oversampling</li><li>Consider double-double precision</li><li>Apply regularization</li></ol><h2 id="Implementation-in-SketchySVD.jl"><a class="docs-heading-anchor" href="#Implementation-in-SketchySVD.jl">Implementation in SketchySVD.jl</a><a id="Implementation-in-SketchySVD.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-in-SketchySVD.jl" title="Permalink"></a></h2><p>The package provides three main functions:</p><h3 id="rsvd-Standard-randomized-SVD"><a class="docs-heading-anchor" href="#rsvd-Standard-randomized-SVD"><code>rsvd</code> - Standard randomized SVD</a><a id="rsvd-Standard-randomized-SVD-1"></a><a class="docs-heading-anchor-permalink" href="#rsvd-Standard-randomized-SVD" title="Permalink"></a></h3><pre><code class="language-julia hljs">U, S, V = rsvd(A, k; p=5, q=0, rng=randn, transpose_trick=true)</code></pre><h3 id="rsvd_adaptive-Adaptive-rank-selection"><a class="docs-heading-anchor" href="#rsvd_adaptive-Adaptive-rank-selection"><code>rsvd_adaptive</code> - Adaptive rank selection</a><a id="rsvd_adaptive-Adaptive-rank-selection-1"></a><a class="docs-heading-anchor-permalink" href="#rsvd_adaptive-Adaptive-rank-selection" title="Permalink"></a></h3><pre><code class="language-julia hljs">U, S, V = rsvd_adaptive(A, k_max; tol=1e-10, p=5, q=0, rng=randn)</code></pre><h3 id="Random-Matrix-Generators"><a class="docs-heading-anchor" href="#Random-Matrix-Generators">Random Matrix Generators</a><a id="Random-Matrix-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Random-Matrix-Generators" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Gaussian (default)
U, S, V = rsvd(A, k, rng=gaussian_rng)

# Rademacher
U, S, V = rsvd(A, k, rng=rademacher_rng)

# Sparse Gaussian
U, S, V = rsvd(A, k, rng=sparse_gaussian_rng(0.1))

# SRFT
U, S, V = rsvd(A, k, rng=srft_rng)

# Sparse redux
U, S, V = rsvd(A, k, rng=sparse_rng)</code></pre><h2 id="Comparison:-Batch-rSVD-vs-Streaming-SketchySVD"><a class="docs-heading-anchor" href="#Comparison:-Batch-rSVD-vs-Streaming-SketchySVD">Comparison: Batch rSVD vs Streaming SketchySVD</a><a id="Comparison:-Batch-rSVD-vs-Streaming-SketchySVD-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison:-Batch-rSVD-vs-Streaming-SketchySVD" title="Permalink"></a></h2><table><tr><th style="text-align: right">Aspect</th><th style="text-align: right">rSVD</th><th style="text-align: right">SketchySVD</th></tr><tr><td style="text-align: right"><strong>Input</strong></td><td style="text-align: right">Full matrix required</td><td style="text-align: right">Streaming columns</td></tr><tr><td style="text-align: right"><strong>Memory</strong></td><td style="text-align: right"><span>$O(mn + m\ell + n\ell)$</span></td><td style="text-align: right"><span>$O(k(m+n) + s^2)$</span></td></tr><tr><td style="text-align: right"><strong>Speed</strong></td><td style="text-align: right">Fast (BLAS Level 3)</td><td style="text-align: right">Moderate (streaming)</td></tr><tr><td style="text-align: right"><strong>Online</strong></td><td style="text-align: right">No</td><td style="text-align: right">Yes</td></tr><tr><td style="text-align: right"><strong>Forgetting</strong></td><td style="text-align: right">No</td><td style="text-align: right">Yes (<span>$\eta, \nu$</span>)</td></tr><tr><td style="text-align: right"><strong>Use case</strong></td><td style="text-align: right">Batch processing</td><td style="text-align: right">Streaming/online</td></tr></table><p><strong>When to use rSVD</strong>: All data available, maximum speed, one-time computation</p><p><strong>When to use SketchySVD</strong>: Streaming data, memory constrained, time-varying subspaces</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sketching/">« Sketching Algorithms</a><a class="docs-footer-nextpage" href="../quickstart/">Getting Started »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 26 November 2025 14:57">Wednesday 26 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
